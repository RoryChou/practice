{"version":3,"sources":["part1_chapter3.js"],"names":[],"mappings":"AAAA;;;AAGA;;AAEA;AACA;AACA,CAAC,SAAS,IAAT,CAAe,GAAf,EAAqB;AAClB,QAAK,MAAL;AACH,CAFD,EAEG,SAAS,GAAT,CAAc,MAAd,EAAuB;AACtB,QAAI,IAAI,CAAR;AACA,YAAQ,GAAR,CAAa,CAAb,EAFsB,CAEJ;AAClB,YAAQ,GAAR,CAAa,OAAO,CAApB,EAHsB,CAGG;AAC5B,CAND;;AAQA;AACA,KAAK,IAAI,IAAE,CAAX,EAAc,IAAE,EAAhB,EAAoB,GAApB,EAAyB;AACrB,YAAQ,GAAR,CAAa,CAAb;AACH,C,CAAA;AACD;AACA,IAAI;AACA,gBADA,CACa;AAChB,CAFD,CAGA,OAAO,GAAP,EAAY;AACR,YAAQ,GAAR,CAAa,GAAb,EADQ,CACY;AACvB;AACD,QAAQ,GAAR,CAAa,GAAb,E,CAAoB;;AAEpB;AACA;;AAEA,IAAI,MAAM,IAAV;AACA,IAAI,GAAJ,EAAS;AACL,QAAI,MAAM,MAAM,CAAhB;AACA,UAAM,UAAW,GAAX,CAAN;AACA,YAAQ,GAAR,CAAa,GAAb;AACH,CAAC,QAAQ,GAAR,CAAa,GAAb,E,CAAoB;AACtB;;AAEA,IAAI,GAAJ,EAAS;AACL;AAAE;AACE,YAAI,MAAM,MAAM,CAAhB;AACA,cAAM,UAAW,GAAX,CAAN;AACA,gBAAQ,GAAR,CAAa,GAAb;AACH;AACJ,C,CAAA;AACD;;AAEA;AACI,YAAQ,GAAR,CAAa,GAAb,EADJ,CACwB;AACpB,QAAI,MAAM,CAAV;AACH;;AAED;AACA,SAAS,OAAT,CAAiB,IAAjB,EAAuB;AACvB;AACC;AACD,IAAI,oBAAoB,EAAxB;AACA,QAAS,iBAAT;AACA,IAAI,MAAM,SAAS,cAAT,CAAyB,WAAzB,CAAV;AACA,IAAI,gBAAJ,CAAsB,OAAtB,EAA+B,SAAS,KAAT,CAAe,GAAf,EAAoB;AAC/C,YAAQ,GAAR,CAAY,gBAAZ;AACH,CAFD,EAEG,mBAAmB,KAFtB;AAGA;;;;;AAKA;AACA;;AAEA,KAAK,IAAI,IAAE,CAAX,EAAc,IAAE,EAAhB,EAAoB,GAApB,EAAyB;AACrB,YAAQ,GAAR,CAAa,CAAb;AACH,CAAC,QAAQ,GAAR,CAAa,CAAb,E,CAAkB;;;AAGpB;;;AAGA;AACA,IAAI,MAAM,IAAV;AACA,IAAI,GAAJ,EAAS;AACL,QAAI,IAAI,CAAR;AACA,UAAM,IAAI,CAAV,CAFK,CAEQ;AACb,QAAI,CAAJ,CAHK,CAGE;AACP;AACH,CAAC;AACF,OAAO,GAAP,CAAY,CAAZ,E,CAAiB;AACjB,QAAQ,GAAR,CAAa,CAAb,E,CAAkB","file":"part1_chapter3-compiled.js","sourcesContent":["/**\r\n * Created by Administrator on 2016/12/14.\r\n */\r\n/* 函数作用域与块作用域 */\r\n\r\n// IIFE：(function foo(){ .. })()与(function(){ .. }())是一样的，\r\n//奇怪的用法\r\n(function IIFE( def ) {\r\n    def( window );\r\n})(function def( global ) {\r\n    var a = 3;\r\n    console.log( a ); // 3\r\n    console.log( global.a ); // 2\r\n});\r\n\r\n/*3.4块作用域*/\r\nfor (var i=0; i<10; i++) {\r\n    console.log( i );\r\n}//并不是块级作用域\r\n//with，try/catch语句\r\ntry {\r\n    undefined(); // 执行一个非法操作来强制制造一个异常\r\n}\r\ncatch (err) {\r\n    console.log( err ); // 能够正常执行！\r\n}\r\nconsole.log( err ); // ReferenceError: err not found\r\n\r\n//let语句（ES6）\r\n/*let 关键字可以将变量绑定到所在的任意作用域中（ 通常是 { .. } 内部）。 换句话说， let\r\n 为其声明的变量隐式地了所在的块作用域。*/\r\nvar foo = true;\r\nif (foo) {\r\n    let bar = foo * 2;\r\n    bar = something( bar );\r\n    console.log( bar );\r\n} console.log( bar ); // ReferenceError\r\n/*只要声明是有效的， 在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑\r\n 定的块*/\r\nif (foo) {\r\n    { // <-- 显式的块\r\n        let bar = foo * 2;\r\n        bar = something( bar );\r\n        console.log( bar );\r\n    }\r\n}//推荐使用这样显式的方式\r\n/*但是使用 let 进行的声明不会在块作用域中进行提升。 声明的代码被运行之前， 声明并不\r\n “ 存在”。*/\r\n{\r\n    console.log( bar ); // ReferenceError!\r\n    let bar = 2;\r\n}\r\n\r\n/* 解决垃圾回收问题 */\r\nfunction process(data) {\r\n// 在这里做点有趣的事情\r\n}\r\nvar someReallyBigData = {};\r\nprocess( someReallyBigData );\r\nvar btn = document.getElementById( \"my_button\" );\r\nbtn.addEventListener( \"click\", function click(evt) {\r\n    console.log(\"button clicked\");\r\n}, /*capturingPhase=*/false );\r\n/* 由于 click 函数形成\r\n 了一个覆盖整个作用域的闭包， JavaScript 引擎极有可能依然保存着someReallyBigData\r\n 这我就不懂了，click函数为何会成为一个闭包？？？？？？？？？\r\n */\r\n\r\n/* let循环 */\r\n/* for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中， 事实上它将其重新绑定到了循环\r\n 的每一个迭代中， 确保使用上一个循环迭代结束时的值重新进行赋值*/\r\nfor (let i=0; i<10; i++) {\r\n    console.log( i );\r\n} console.log( i ); // ReferenceError\r\n\r\n\r\n/*\r\n*   const(ES6)\r\n* */\r\n//用来创建块作用域变量， 但其值是固定的（ 常量）。 之后任何试图修改值的操作都会引起错误。\r\nvar foo = true;\r\nif (foo) {\r\n    var a = 2;\r\n    const b = 3; // 包含在 if 中的块作用域常量\r\n    a = 3; // 正常 !\r\n    //b = 4; // 错误 !\r\n} c\r\nonsole.log( a ); // 3\r\nconsole.log( b ); // ReferenceError!"]}