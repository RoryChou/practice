{"version":3,"sources":["part1_chapter5.js"],"names":[],"mappings":"AAAA;;;AAGA;;;AAGA;AACA;AACA;;AAEA,SAAS,IAAT,CAAc,OAAd,EAAuB;AACnB,eAAY,SAAS,KAAT,GAAiB;AACzB,gBAAQ,GAAR,CAAa,OAAb;AACH,KAFD,EAEG,IAFH;AAGH,CAAC,KAAM,iBAAN;AACF;AACA;;;;;AAMA;AACA,KAAK,IAAI,IAAE,CAAX,EAAc,KAAG,CAAjB,EAAoB,GAApB,EAAyB;AACrB,eAAY,SAAS,KAAT,GAAiB;AACzB,gBAAQ,GAAR,CAAa,CAAb;AACH,KAFD,EAEG,IAAE,IAFL;AAGH;;AAED,KAAK,IAAI,IAAE,CAAX,EAAc,KAAG,CAAjB,EAAoB,GAApB,EAAyB;AACrB,KAAC,UAAS,CAAT,EAAY;AACT,mBAAY,SAAS,KAAT,GAAiB;AACzB,oBAAQ,GAAR,CAAa,CAAb;AACH,SAFD,EAEG,IAAE,IAFL;AAGH,KAJD,EAII,CAJJ;AAKH;AACD;AACA,KAAK,IAAI,IAAE,CAAX,EAAc,KAAG,CAAjB,EAAoB,GAApB,EAAyB;AACrB,QAAI,IAAI,CAAR,CADqB,CACV;AACX,eAAY,SAAS,KAAT,GAAiB;AACzB,gBAAQ,GAAR,CAAa,CAAb;AACH,KAFD,EAEG,IAAE,IAFL;AAGH;AACD;AACA,KAAK,IAAI,IAAE,CAAX,EAAc,KAAG,CAAjB,EAAoB,GAApB,EAAyB;AACrB,eAAY,SAAS,KAAT,GAAiB;AACzB,gBAAQ,GAAR,CAAa,CAAb;AACH,KAFD,EAEG,IAAE,IAFL;AAGH;;AAED;AACA,IAAI,MAAO,SAAS,UAAT,GAAsB;AAC7B,QAAI,YAAY,MAAhB;AACA,QAAI,UAAU,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAd;AACA,aAAS,WAAT,GAAuB;AACnB,gBAAQ,GAAR,CAAa,SAAb;AACH;AACD,aAAS,SAAT,GAAqB;AACjB,gBAAQ,GAAR,CAAa,QAAQ,IAAR,CAAc,KAAd,CAAb;AACH;AACD,WAAO;AACH,qBAAa,WADV;AAEH,mBAAW;AAFR,KAAP;AAIH,CAbS,EAAV;;AAeA;AACA,IAAI,YAAa,SAAS,OAAT,GAAmB;AAChC,QAAI,UAAU,EAAd;AACA,aAAS,MAAT,CAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC;AAC9B,aAAK,IAAI,IAAE,CAAX,EAAc,IAAE,KAAK,MAArB,EAA6B,GAA7B,EAAkC;AAC9B,iBAAK,CAAL,IAAU,QAAQ,KAAK,CAAL,CAAR,CAAV;AACH;AACD,gBAAQ,IAAR,IAAgB,KAAK,KAAL,CAAY,IAAZ,EAAkB,IAAlB,CAAhB;AACH;AACD,aAAS,GAAT,CAAa,IAAb,EAAmB;AACf,eAAO,QAAQ,IAAR,CAAP;AACH;AACD,WAAO;AACH,gBAAQ,MADL;AAEH,aAAK;AAFF,KAAP;AAIH,CAfe,EAAhB;AAgBA;AACA,UAAU,MAAV,CAAkB,KAAlB,EAAyB,EAAzB,EAA6B,YAAW;AACpC,aAAS,KAAT,CAAe,GAAf,EAAoB;AAChB,eAAO,uBAAuB,GAA9B;AACH;AACD,WAAO;AACH,eAAO;AADJ,KAAP;AAGH,CAPD","file":"part1_chapter5-compiled.js","sourcesContent":["/**\r\n * Created by Administrator on 2016/12/14.\r\n */\r\n/*\r\n*   作用域闭包\r\n* */\r\n//当函数可以记住并访问所在的词法作用域时， 就产生了闭包\r\n// 闭包使得函数可以继续访问定义时的词法作用域\r\n//当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。\r\n\r\nfunction wait(message) {\r\n    setTimeout( function timer() {\r\n        console.log( message );\r\n    }, 1000 );\r\n} wait( \"Hello, closure!\" );\r\n//其中的timer()就是闭包\r\n/*无论何时何地， 如果将函数（ 访问它们各自的词法作用域） 当作第一\r\n 级的值类型并到处传递， 你就会看到闭包在这些函数中的应用。在定时器、 事件监听器、\r\n Ajax 请求、 跨窗口通信、 Web Workers 或者任何其他的异步（ 或者同步） 任务中， 只要使\r\n 用了回调函数， 实际上就是在使用闭包！*/\r\n\r\n\r\n/*要说明闭包， for 循环是最常见的例子*/\r\nfor (var i=1; i<=5; i++) {\r\n    setTimeout( function timer() {\r\n        console.log( i );\r\n    }, i*1000 );\r\n}\r\n\r\nfor (var i=1; i<=5; i++) {\r\n    (function(j) {\r\n        setTimeout( function timer() {\r\n            console.log( j );\r\n        }, j*1000 );\r\n    })( i );\r\n}\r\n/*换句话说， 每次迭代我们都需要一个块作用域*/\r\nfor (var i=1; i<=5; i++) {\r\n    let j = i; // 是的， 闭包的块作用域！\r\n    setTimeout( function timer() {\r\n        console.log( j );\r\n    }, j*1000 );\r\n}\r\n/* 变量在循环过程中不止被声明一次， 每次迭代都会声明。 */\r\nfor (let i=1; i<=5; i++) {\r\n    setTimeout( function timer() {\r\n        console.log( i );\r\n    }, i*1000 );\r\n}\r\n\r\n/* 模块 */\r\nvar foo = (function CoolModule() {\r\n    var something = \"cool\";\r\n    var another = [1, 2, 3];\r\n    function doSomething() {\r\n        console.log( something );\r\n    }\r\n    function doAnother() {\r\n        console.log( another.join( \" ! \" ) );\r\n    }\r\n    return {\r\n        doSomething: doSomething,\r\n        doAnother: doAnother\r\n    };\r\n})();\r\n\r\n/* 现代模块 */\r\nvar MyModules = (function Manager() {\r\n    var modules = {};\r\n    function define(name, deps, impl) {\r\n        for (var i=0; i<deps.length; i++) {\r\n            deps[i] = modules[deps[i]];\r\n        }\r\n        modules[name] = impl.apply( impl, deps );\r\n    }\r\n    function get(name) {\r\n        return modules[name];\r\n    }\r\n    return {\r\n        define: define,\r\n        get: get\r\n    };\r\n})();\r\n//定义模块\r\nMyModules.define( \"bar\", [], function() {\r\n    function hello(who) {\r\n        return \"Let me introduce: \" + who;\r\n    }\r\n    return {\r\n        hello: hello\r\n    };\r\n} );"]}